---
title: "Machine Dial Graphics"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

Generated on: `r Sys.time()`

```{r, libraries, echo=FALSE}
library(tibble)
```

# Properties:

```{r, functions, echo=FALSE}
mm_to_in <- function(mm) {return(mm / 25.4)}
```

## Motor:

```{r, motor properties}
max_hz <- 70
min_hz <- 22
motor_pulley_diameters <- c(2, 3, 4, 5)
motor_rpm <- 1725
```
```{r, motor_functions, echo=FALSE}
hz_to_motor_rpm <- function(hz, motor_rpms = motor_rpm) {
  return(round(hz / 60 * motor_rpms))
}
```

## Drill Press:

```{r, drill-press}
spindle_pulley_diameters <- c(7.25, 6.25, 5.25, 4.5)
```

## Dial:

```{r, dial}
dial_gap_mm <- 2 # leave space around outside of dial
dial_diameter_in <- mm_to_in(45 + 2 * dial_gap_mm) 
dial_rotation <- 312 # degrees
mounting_hole_dia_in <- 0.375
```

# RPM Ranges:

Using a fixed number of divisions resulted in each of the scales having weird RPM values at major tick marks. Confirm that each pulley step range is different.

```{r, speed-ranges, echo=FALSE}
pulley_multipler <- motor_pulley_diameters / spindle_pulley_diameters
speed_ranges <- round(hz_to_motor_rpm((max_hz - min_hz) * pulley_multipler))
min_spindle <- hz_to_motor_rpm(min_hz) * pulley_multipler
max_spindle <- hz_to_motor_rpm(max_hz) * pulley_multipler
range <- round(max_spindle - min_spindle)
min_max_spindle_rpms <- tibble(pulley_multipler, min_spindle, max_spindle, range)
```
The RPM ranges are `r speed_ranges`.

The table is `r min_max_spindle_rpms`.

# Calculating Scales:

```{r, stuff}
# scale_divisions <- scale_ticks - 1
scale_band_width_in <- (3.4375 - dial_diameter_in) / 2 # 3 7/16 in
scaling_mod = 5
min_scale_hz = round(min_hz / scaling_mod) * scaling_mod
max_scale_hz = round(max_hz / scaling_mod) * scaling_mod
# hertz_scale = seq(min_scale_hz, max_scale_hz, (max_scale_hz - min_scale_hz)/ scale_divisions)

rpm_scale <- function(freq_scale, pulley_ratio, motor_rpm = motor_rpm) {
  return(round(motor_rpm * pulley_ratio * freq_scale / 60))
}
# right now a band is 5/32" wide
```

Scatch calcuations:

```{r, scratch-calcs}
scale_value <- function(value, factor = 5) {
  return(value %/% factor * factor)
}

## figure out how add columns to existing tibble in tidyverse way

start_angle <- 270 + (360 - dial_rotation)/2
stop_angle <- 270 - (360 - dial_rotation)/2
start_angle
stop_angle
# scale_tick_angle <- (start_angle - stop_angle) / scale_divisions
# stop_angle / scale_tick_angle
```
# Circos Package

Trying out Circos package, https://cran.r-project.org/web/packages/BioCircos/vignettes/BioCircos.html#introduction.

```{r, circos}
library(BioCircos)
BioCircos(genome = "hg19", yChr = FALSE, genomeFillColor = "Blues", chrPad = 0, 
  displayGenomeBorder = TRUE, genomeTicksDisplay = TRUE, genomeLabelDy = 0)
```
Now try background track
```{r}
library(BioCircos)
tracklist = BioCircosBackgroundTrack("myBackgroundTrack", minRadius = dial_diameter_in / 2, maxRadius = dial_diameter_in / 2 + scale_band_width_in,
  borderColors = "#AAAAAA", borderSize = 0.6, fillColors = "#FFBBBB")  

BioCircos(tracklist, genomeFillColor = "PuOr",
  chrPad = 0.05, displayGenomeBorder = TRUE, 
  genomeTicksDisplay = TRUE,  genomeLabelTextSize = "9pt", genomeLabelDy = 0)
```


```{r, multi-track}
library(BioCircos)

# Fix random generation for reproducibility
set.seed(3)

# Background and text tracks
tracks = BioCircosBackgroundTrack("testBGtrack1", minRadius = 0.3, maxRadius = 0.45,
  borderColors = "#FFFFFF", borderSize = 0.6)    
tracks = tracks + BioCircosBackgroundTrack("testBGtrack2", borderColors = "#FFFFFF", 
  fillColor = "#FFEEEE", borderSize = 0.6, maxRadius = 0.8)
# tracks = tracks + BioCircosTextTrack("testText", 'BioCircos!', weight = "lighter", 
#   x = - 0.17, y = - 0.87)

# Arc track
arcsEnds = round(runif(7, 50000001, 133851895))
arcsLengths = round(runif(7, 1, 50000000))
tracks = tracks + BioCircosArcTrack("fredTestArc", as.character(sample(1:12, 7, replace=T)), 
  starts = arcsEnds - arcsLengths, ends = arcsEnds, labels = 1:7, 
  maxRadius = 0.97, minRadius = 0.83)

# Display the BioCircos visualization
BioCircos(tracks, genomeFillColor = "Spectral", yChr = T, chrPad = 0, displayGenomeBorder = F, 
  genomeTicksLen = 3, genomeTicksTextSize = 0, genomeTicksScale = 50000000,
  genomeLabelTextSize = 18, genomeLabelDy = 0)
```
So it seems like this package can be used to make a dial.

# Circlize Package

Moving onto [Circular Visualization in R](https://jokergoo.github.io/circlize_book/book/)

Clock example look simliar to a scale...
```{r, clock-example}
library(circlize)
circos.clear()
circos.par(gap.degree = 0, cell.padding = c(0, 0, 0, 0), start.degree = 90)
circos.initialize(factors = "a", xlim = c(0, 12))
circos.track(ylim = c(0, 1), bg.border = NA)
circos.axis(major.at = 0:12, labels = NULL, direction = "inside", 
    major.tick.length = uy(2, "mm"))
circos.text(1:12, rep(1, 12) - uy(6, "mm"), 1:12, facing = "downward")

current.time = as.POSIXlt(Sys.time())
sec = ceiling(current.time$sec)
min = current.time$min
hour = current.time$hour

sec.degree = 90 - sec/60 * 360
arrows(0, 0, cos(sec.degree/180*pi)*0.8, sin(sec.degree/180*pi)*0.8)

min.degree = 90 - min/60 * 360
arrows(0, 0, cos(min.degree/180*pi)*0.7, sin(min.degree/180*pi)*0.7, lwd = 1)   

hour.degree = 90 - hour/12 * 360 - min/60 * 360/12
arrows(0, 0, cos(hour.degree/180*pi)*0.4, sin(hour.degree/180*pi)*0.4, lwd = 2)
```

