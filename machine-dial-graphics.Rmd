---
title: "Machine Dial Graphics"
output:
  html_notebook: default
  html_document:
    df_print: paged
  pdf_document: default
---

Generated on: `r Sys.time()`

```{r libraries, echo=FALSE}
library(tibble)
```

# What is it?

The idea is to programmatically design a speed dial that a person can use to set the spindle RPM on a machine too. In my case, for a Delta DP220 drill press. Here's a two speed dial for a Bridgeport Mill. 

![](https://www.practicalmachinist.com/vb/attachments/f20/7566d1226352266-speed-dial-bridgeport-2j-speed-dial-rotated.jpg){width=40%}

The canonical form of the problem needs to deal with the number of scales, the range of each scale, the resolution of ticks for each scale, and creating the bands to fit in the available space.

Inkscape's Ruler plug-in could do this job, but it's a fair bit of work to redo scales.

# Properties:

The drill press is setup with 4 step pulleys and a variable speed motor (VFD controller).

```{r functions, echo=FALSE}
mm_to_in <- function(mm) {return(mm / 25.4)}
```

## Motor:

```{r motor-properties}
max_hz <- 70
min_hz <- 22
motor_pulley_diameters <- c(2, 3, 4, 5)
motor_rpm <- 1725
```

```{r motor_functions, echo=FALSE}
hz_to_motor_rpm <- function(hz, motor_rpms = motor_rpm) {
  return(round(hz / 60 * motor_rpms))
}
```

## Drill Press:

```{r drill_press}
spindle_pulley_diameters <- c(7.25, 6.25, 5.25, 4.5)
```

## Dial:

The potentiometer and knob determine the dimensions below.
```{r dial}
dial_gap_mm <- 2 # leave space around outside of dial
dial_diameter_in <- mm_to_in(45 + 2 * dial_gap_mm) 
dial_rotation <- 312 # degrees
mounting_hole_dia_in <- 0.375
```

# RPM Ranges:

Using a fixed number of divisions resulted in each of the scales having weird RPM values at major tick marks. Here is the speed range for each pulley ratio.

```{r speed-ranges, echo=FALSE}
pulley_multipler <- motor_pulley_diameters / spindle_pulley_diameters
speed_ranges <- round(hz_to_motor_rpm((max_hz - min_hz) * pulley_multipler))
min_spindle <- hz_to_motor_rpm(min_hz) * pulley_multipler
max_spindle <- hz_to_motor_rpm(max_hz) * pulley_multipler
range <- round(max_spindle - min_spindle)
min_max_spindle_rpms <- tibble(pulley_multipler, min_spindle, max_spindle, range)
```

The table of raw data is `r min_max_spindle_rpms`.

# Calculating Scales:

First step is to normalize the scale end points. Picked a multiple of 5.

```{r scales, echo=FALSE}
scale_value <- function(value, factor = 5) {
  return(value %/% factor * factor)
}
min_scale <- as.integer(scale_value(hz_to_motor_rpm(min_hz) * pulley_multipler))
max_scale <- as.integer(scale_value(hz_to_motor_rpm(max_hz) * pulley_multipler))
range <- max_scale - min_scale
min_max_scale_rpms <- tibble(pulley_multipler, min_scale, max_scale, range)
```
The scales data is `r min_max_scale_rpms`


Next figure out the precision of setting the speed or the steps between tick marks.  Manually try:
```{r scale-values}
s1 <- c(170, 200, 250, 300, 350, 350, 400, 450, 500, 555)
```

# Random calcuations:

Save some paper calculations for possible later use.

```{r scratch-calcs}
start_angle <- 270 + (360 - dial_rotation)/2
stop_angle <- 270 - (360 - dial_rotation)/2
start_angle
stop_angle
# scale_tick_angle <- (start_angle - stop_angle) / scale_divisions
# stop_angle / scale_tick_angle
scale_band_width_in <- (3.4375 - dial_diameter_in) / 2 # 3 7/16 in

# min_scale_hz = round(min_hz / scaling_mod) * scaling_mod
# max_scale_hz = round(max_hz / scaling_mod) * scaling_mod
# # hertz_scale = seq(min_scale_hz, max_scale_hz, (max_scale_hz - min_scale_hz)/ scale_divisions)
# 
# rpm_scale <- function(freq_scale, pulley_ratio, motor_rpm = motor_rpm) {
#   return(round(motor_rpm * pulley_ratio * freq_scale / 60))
# }
# right now a band is 5/32" wide
```
# Investigate Plotting Packages

Found 2 packages that offer some possibilities.

## Circos Package

CRAN:  https://cran.r-project.org/web/packages/BioCircos/vignettes/BioCircos.html#introduction.

```{r circos}
library(BioCircos)
BioCircos(genome = "hg19", yChr = FALSE, genomeFillColor = "Blues", chrPad = 0, 
  displayGenomeBorder = TRUE, genomeTicksDisplay = TRUE, genomeLabelDy = 0)
```
Now try background track
```{r}
library(BioCircos)
tracklist = BioCircosBackgroundTrack("myBackgroundTrack", minRadius = dial_diameter_in / 2, maxRadius = dial_diameter_in / 2 + scale_band_width_in,
  borderColors = "#AAAAAA", borderSize = 0.6, fillColors = "#FFBBBB")  

BioCircos(tracklist, genomeFillColor = "PuOr",
  chrPad = 0.05, displayGenomeBorder = TRUE, 
  genomeTicksDisplay = TRUE,  genomeLabelTextSize = "9pt", genomeLabelDy = 0)
```


```{r multi-track}
library(BioCircos)

# Fix random generation for reproducibility
set.seed(3)

# Background and text tracks
tracks = BioCircosBackgroundTrack("testBGtrack1", minRadius = 0.3, maxRadius = 0.45,
  borderColors = "#FFFFFF", borderSize = 0.6)    
tracks = tracks + BioCircosBackgroundTrack("testBGtrack2", borderColors = "#FFFFFF", 
  fillColor = "#FFEEEE", borderSize = 0.6, maxRadius = 0.8)
# tracks = tracks + BioCircosTextTrack("testText", 'BioCircos!', weight = "lighter", 
#   x = - 0.17, y = - 0.87)

# Arc track
arcsEnds = round(runif(7, 50000001, 133851895))
arcsLengths = round(runif(7, 1, 50000000))
tracks = tracks + BioCircosArcTrack("fredTestArc", as.character(sample(1:12, 7, replace=T)), 
  starts = arcsEnds - arcsLengths, ends = arcsEnds, labels = 1:7, 
  maxRadius = 0.97, minRadius = 0.83)

# Display the BioCircos visualization
BioCircos(tracks, genomeFillColor = "Spectral", yChr = T, chrPad = 0, displayGenomeBorder = F, 
  genomeTicksLen = 3, genomeTicksTextSize = 0, genomeTicksScale = 50000000,
  genomeLabelTextSize = 18, genomeLabelDy = 0)
```
So it seems like this package can be used to make a dial.

## Circlize Package

Moving onto [Circular Visualization in R](https://jokergoo.github.io/circlize_book/book/)

Clock example look simliar to a scale...
```{r clock-example}
library(circlize)
circos.clear()
circos.par(gap.degree = 0, cell.padding = c(0, 0, 0, 0), start.degree = 90)
circos.initialize(factors = "a", xlim = c(0, 12))
circos.track(ylim = c(0, 1), bg.border = NA)
circos.axis(major.at = 0:12, labels = NULL, direction = "inside", 
    major.tick.length = uy(2, "mm"))
circos.text(1:12, rep(1, 12) - uy(6, "mm"), 1:12, facing = "downward")

current.time = as.POSIXlt(Sys.time())
sec = ceiling(current.time$sec)
min = current.time$min
hour = current.time$hour

sec.degree = 90 - sec/60 * 360
arrows(0, 0, cos(sec.degree/180*pi)*0.8, sin(sec.degree/180*pi)*0.8)

min.degree = 90 - min/60 * 360
arrows(0, 0, cos(min.degree/180*pi)*0.7, sin(min.degree/180*pi)*0.7, lwd = 1)   

hour.degree = 90 - hour/12 * 360 - min/60 * 360/12
arrows(0, 0, cos(hour.degree/180*pi)*0.4, sin(hour.degree/180*pi)*0.4, lwd = 2)
```

